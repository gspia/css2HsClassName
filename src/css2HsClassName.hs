{-# LANGUAGE OverloadedStrings #-}
module Main where

--------------------------------------------------------------------------------
-- css2HsClassName
--
-- About structure:
--   We use two almost similar ways to transform tokens to text. The other one
--   is used to recognize tokens.
--   And the second one doesn't need that prefix recognition but uses it
--   to give a prefix for function names this produces.
--
--------------------------------------------------------------------------------

import           Data.Char    (isNumber)
import           Data.CSS.Syntax.Tokens (tokenize, Token(Ident, Delim))
import           Data.List    (sort, nub)
import           Data.Monoid  ((<>))
import qualified Data.Text    as T
import qualified Data.Text.IO as T
import           System.Environment (getArgs)
import           System.IO (stdin, stdout)


--------------------------------------------------------------------------------
-- Some constants affecting how the module-files are named.
--------------------------------------------------------------------------------

-- These are path-components in module-structure.
-- Functions writehs, mkhsClass as well as the icon-producing
-- function at the end of this file have the rest of the constants...
themeDir, iconDir, modulePrefix :: T.Text
themeDir     = "Themes"
iconDir      = "Icons"
modulePrefix = "Reflex.Dom."

cssInputDir, resultDir :: FilePath
cssInputDir = "./css"
resultDir   = "./res"

--------------------------------------------------------------------------------
-- Parse css-file and try to get something out of it.
--------------------------------------------------------------------------------

isDelim :: Token -> Bool
isDelim (Delim '.') = True
isDelim _ = False

isIdent :: Token -> Bool
isIdent (Ident _) = True
isIdent _ = False

getIdents :: [Token] -> [Token]
getIdents [] = []
getIdents [_b] = []
getIdents (a:b:rest) = sel ++ getIdents rst
  where
    (sel,rst) =
      if isDelim a && isIdent b
         then ([b], rest)
         else ([], b:rest)


--------------------------------------------------------------------------------
-- Read file
--------------------------------------------------------------------------------

file2tokens :: FilePath -> IO [Token]
file2tokens file = fmap txt2toks (T.readFile file) -- >>= return . txt2toks

stdin2tokens :: IO [Token]
stdin2tokens = fmap txt2toks (T.hGetContents stdin) -- >>= return . txt2toks

txt2toks :: T.Text -> [Token]
txt2toks txt =
  case tokenize txt of
    Left _     -> []
    Right toks -> getIdents toks

--------------------------------------------------------------------------------
-- Produce a haskell-module contents.
--------------------------------------------------------------------------------

mkhsClass :: (T.Text, T.Text) -> T.Text
mkhsClass (clName, css) = T.concat [clName, cNt, clName, cNv, css, nls]
  where
    cNt = " :: ClassName\n"
    cNv = " = ClassName \""
    nls = "\"\n\n"

mkHsModule :: T.Text -> T.Text -> T.Text -> T.Text
mkHsModule subd mname t = h <> t
  where
    h = T.concat
      [ "{-# LANGUAGE OverloadedStrings #-}\n"
      -- , "module Reflex.Dom.Themes.Raw."
      -- , "module Reflex.Dom.Icons.Raw."
      , "module ", modulePrefix, subd, ".Raw.", mname
      , " where\n\n"
      , "import Reflex.Dom.HTML5.Attrs (ClassName (ClassName))\n\n\n"
      , "-- This file is automatically generated. \n\n\n"
      ]

--------------------------------------------------------------------------------
-- Used by both handlers.
--------------------------------------------------------------------------------

mkhsContents :: [(T.Text, T.Text)] -> T.Text
mkhsContents = T.concat . fmap mkhsClass . sort

toCamelCase :: T.Text -> T.Text
toCamelCase wo =
  if not (null lst)
     then T.concat $ head lst : fmap T.toTitle (tail lst)
     else T.empty
  where
    lst = concatMap (T.split (=='_')) $ T.split (=='-') wo

-- Semantic css theme has a class starting with a number.
-- This puts the number at the end of className in rather naive way.
-- If using prefixes, there is no need for this method.
numBeg :: T.Text -> T.Text
numBeg w =
  if nw /= T.empty
     then re <> nw
     else w
  where
    nw = T.takeWhile isNumber w
    re = T.dropWhile isNumber w

-- For reserved and other common words (common in other libs).
-- If using prefixes for ClassNames, there is no need for these
-- but without prefixes, e.g. Semantic css theme has "do"-class etc.
resWords :: T.Text -> T.Text
resWords w =
  if w `elem` ["do", "in", "of", "on", "or", "and", "try"]
     then w <> "Cl"
     else w

-- Args:
--   subd  - subdirectory in the module name path (e.g. Themes or Icons)
--   modNm - module name in module name path (coming after "Raw")
--   pref  - prefix to be recognized in each Token
--           or to be added to each ClassName.
--   tokens - list of tokens received from file
--   fun   - either css2tt or prefixedCss (a function to be used to
--           transform Token to (Text,Text), that is the
--           pair (function name to be written, class name as text).
--           In a way, this makes the decision, how the pref arg is used.
mkHsFromCss :: T.Text -> T.Text -> T.Text -> [Token]
            -> (T.Text -> [Token] -> [(T.Text, T.Text)]) -> T.Text
mkHsFromCss subd mname pref tokens fun =
  mkHsModule subd mname ((mkhsContents . fun pref) tokens)


-- Args:
--   subd  - subdirectory in the module name path (e.g. Themes or Icons)
--   modNm - module name in module name path (coming after "Raw")
--   pref  - prefix to be added to each ClassName-function.
--   inf   - input file
--   outf  - output file
--   fun   - either prefixedCss or css2tt
mkWithFun :: T.Text -> T.Text -> T.Text -> FilePath -> FilePath
          -> (T.Text -> [Token] -> [(T.Text, T.Text)]) -> IO ()
mkWithFun subd modNm pref inf outf fun = do
  tokens <- file2tokens inf
  let txt = mkHsFromCss subd modNm pref tokens fun
  T.writeFile outf txt

mkWithFun2 :: T.Text -> T.Text -> T.Text
           -> (T.Text -> [Token] -> [(T.Text, T.Text)]) -> IO ()
mkWithFun2 subd modNm pref fun = do
  tokens <- stdin2tokens
  let txt = mkHsFromCss subd modNm pref tokens fun
  T.hPutStr stdout txt

--------------------------------------------------------------------------------
-- For those tokens that don't have prefixes.
-- Mainly for css-theme files.
--------------------------------------------------------------------------------

tok2txt :: [Token] -> [T.Text]
tok2txt = nub . fmap ident2txt

-- By reorganizing, we could get away from this method.
-- (The getIdents could return Text right away.)
ident2txt :: Token -> T.Text
ident2txt (Ident txt) = txt
ident2txt _ = T.empty

-- Args:
--   pref is a prefix to be added to each written function (can be empty, too).
-- Outputs a list of pairs of (function name, css-class string)
css2tt :: T.Text -> [Token] -> [(T.Text, T.Text)]
css2tt pref = fmap (\w -> (fn w, w)) . tok2txt
  where
    -- Note that two different class names may map to the same function
    -- name quite easily. E.g. "wi-fi" and "wifi"
    fn = resWords . numBeg . toCamelCase . preW
    -- This way since we want to camel case if a prefix is used.
    preW w = if pref /= T.empty
                then pref <> "_" <> w
                else w

-- This is a ghci helper (see below), not needed in executable.
-- Args:
--   subd  - subdirectory in the module name path (e.g. Themes or Icons)
--   modNm - module name in module name path (coming after "Raw")
--   pref  - prefix to be added to each ClassName-function.
--   inf   - input file
--   outf  - output file
mkWithPreWrite :: T.Text -> T.Text -> T.Text -> FilePath -> FilePath -> IO ()
mkWithPreWrite subd modNm pref inf outf =
  mkWithFun subd modNm pref inf outf css2tt

--------------------------------------------------------------------------------
-- For those tokens that have prefixes.
-- Mainly for icon-css files.
-- Note that the below methods are almost the same as above ones and these
-- could be combined by adding a new parameter (so that we would have a prefix
-- to be recognized in the tookens and a prefix to be used when writing function
-- names).
--------------------------------------------------------------------------------

-- get, remove duplicates and as text.
getPrefixTokens :: T.Text -> [Token] -> [T.Text]
getPrefixTokens pre = nub . filter (T.isPrefixOf pre) . fmap ident2txt

-- Args:
--   pref  - a prefix to be found from css Tokens
-- Outputs a list of pairs of (function name, css-class string)
prefixedCss :: T.Text -> [Token] -> [(T.Text, T.Text)]
prefixedCss pref = fmap (\w -> (fn w, w)) . getPrefixTokens pref
  where
    fn = resWords . numBeg . toCamelCase

-- This is a ghci helper (see below), not needed in executable.
-- Args:
--   subd  - subdirectory in the module name path (e.g. Themes or Icons)
--   modNm - module name in module name path (coming after "Raw")
--   pref  - prefix to be recognized in each Token
--   inf   - input file
--   outf  - output file
mkWithPreRecog :: T.Text -> T.Text -> T.Text -> FilePath -> FilePath -> IO ()
mkWithPreRecog subd modNm pref inf outf =
  mkWithFun subd modNm pref inf outf prefixedCss

--------------------------------------------------------------------------------
-- Main with helpers.
--------------------------------------------------------------------------------

main :: IO ()
main = do
  args <- getArgs -- >>= return . fmap T.pack
  let
    modNm = T.pack $ head args -- !!0 (since hlint asks for head)
    pref  = T.pack $ args!!1
    iort  = T.pack $ args!!2
    inf   = args!!3
    ouf   = args!!4
    icons = "Icons"
    themes = "Themes"
  if any (\arg -> head arg == '-') args
     then T.putStr help
     else
        case length args of
          3 ->
            case iort of
              "icon"  -> mkWithFun2 icons modNm pref prefixedCss
              "theme" -> mkWithFun2 themes modNm pref css2tt
              _       -> unknown3
          5 ->
            case iort of
              "icon"  -> mkWithFun icons modNm pref inf ouf prefixedCss
              "theme" -> mkWithFun themes modNm pref inf ouf css2tt
              _       -> unknown3
          _ -> T.putStr help

unknown3 :: IO ()
unknown3 = do
  T.putStrLn "Unknown 3rd parameter, it should be either icon or theme.\n"
  T.putStrLn help

help :: T.Text
help =
  "Usage:\n \
  \  css2HsClassName modNm prefix (icon|theme) [infile outfile]\n \
  \    where\n \
  \    modNm  = module name in the produced Haskell file\n \
  \    prefix = either a prefix to be recognized before each css-token\n \
  \             or a prefix to be written before each classname-function.\n\n \
  \ Examples:\n \
  \   css2HsClassName BS4 bs theme < ./bootstrap.css > ./BS4.hs \n \
  \ and\n \
  \   css2HsClassName BS4 bs theme ./bootstrap.css ./BS4.hs \n \
  \ do the same thing.\n \
  \ To process icon css-files:\n \
  \   css2HsClassName FA fa icon < ./font-awesome.css > FA.hs \n\n"


--------------------------------------------------------------------------------
-- The following are handy with ghci.
-- They are not used in the executable, which is why they are in comments.
--------------------------------------------------------------------------------

{-
--------------------------------------------------------------------------------
-- Icon producing files.
--------------------------------------------------------------------------------

faProd :: IO () -- Font awesome
faProd = mkWithPreRecog iconDir "FA" "fa" inFA outFA

inFA, outFA :: FilePath
inFA = cssInputDir <> "/font-awesome.css"
outFA = resultDir <> "/FA.hs"

elusiveProd :: IO ()
elusiveProd = mkWithPreRecog iconDir "ElusiveIcons" "el" inEI outEI

inEI, outEI :: FilePath
-- inEI = cssInputDir <> "/elusive-webfont.css"
inEI = cssInputDir <> "/elusive-icons.css"
outEI = resultDir <> "/ElusiveIcons.hs"

fiProd :: IO ()
fiProd = mkWithPreRecog iconDir "Foundation" "fi" inFI outFI

inFI, outFI :: FilePath
inFI = cssInputDir <> "/foundation-icons.css"
outFI = resultDir <> "/Foundation.hs"

icomoonProd :: IO ()
icomoonProd = mkWithPreRecog iconDir "Icomoon" "icon" inIcom outIcom

inIcom, outIcom :: FilePath
inIcom = cssInputDir <> "/IcoMoon.css"
outIcom = resultDir <> "/Icomoon.hs"

ionProd :: IO ()
ionProd = mkWithPreRecog iconDir "Ionicons" "ion" inIon outIon

inIon, outIon :: FilePath
inIon = cssInputDir <> "/ionicons.css"
outIon = resultDir <> "/Ionicons.hs"

matDesignProd :: IO ()
matDesignProd = mkWithPreRecog iconDir "MDI" "mdi" inMfg outMfg

inMDI, outMDI :: FilePath
inMDI = cssInputDir <> "/materialdesignicons.css"
outMDI = resultDir <> "/MDI.hs"

mfgProd :: IO ()
mfgProd = mkWithPreRecog iconDir "MfgLabs" "icon" inMfg outMfg

inMfg, outMfg :: FilePath
inMfg = cssInputDir <> "/mfglabs_iconset.css"
outMfg = resultDir <> "/MfgLabs.hs"

-- modUIProd :: IO ()
-- modUIProd = mkWithPreRecog iconDir "ModernUI" "icon" inModUI outModUI

-- inModUI, outModUI :: FilePath
-- inModUI = cssInputDir <> "/modernuidrawing.css"
-- outModUI = resultDir <> "/ModernUI.hs"

oiProd :: IO ()
oiProd = mkWithPreRecog iconDir "OpenIconic" "oi" inOI outOI

inOI, outOI :: FilePath
inOI = cssInputDir <> "/open-iconic-bootstrap.css"
-- inOI = cssInputDir <> "/open-iconic.css"
outOI = resultDir <> "/OpenIconic.hs"

typiProd :: IO ()
typiProd = mkWithPreRecog iconDir "Typicons" "typcn" inTypi outTypi

inTypi, outTypi :: FilePath
inTypi = cssInputDir <> "/typicons.css"
outTypi = resultDir <> "/Typicons.hs"

flagProd :: IO ()
flagProd = mkWithPreRecog iconDir "FlagIcons" "flag" inFlag outFlag

inFlag, outFlag :: FilePath
inFlag = cssInputDir <> "/flag-icon.css"
outFlag = resultDir <> "/FlagIcons.hs"

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Theme producing declarations.
--------------------------------------------------------------------------------

inpath4 :: FilePath
inpath4 = cssInputDir <> "/bootstrap.css"
outpath4 :: FilePath
outpath4 = resultDir <> "/BS4.hs"

inSemantic :: FilePath
inSemantic = cssInputDir <> "/semantic.css"
outSemantic :: FilePath
outSemantic = resultDir <> "/Semantic.hs"

inFoundation :: FilePath
inFoundation = cssInputDir <> "/foundation.css"
outFoundation :: FilePath
outFoundation = resultDir <> "/Foundation.hs"


bs4gen, semgen, fougen :: IO ()
bs4gen = mkWithPreWrite themeDir "BS4" "bs" inpath4 outpath4
semgen = mkWithPreWrite themeDir "Semantic" "sem" inSemantic outSemantic
fougen = mkWithPreWrite themeDir "Foundation" "fou" inFoundation outFoundation


--------------------------------------------------------------------------------

mkAll = do
  putStrLn "Be careful, the following don't check for file overwrites (at the moment)!"
  faProd
  putStrLn "Wrote Font Awesome icon-hs-file."
  elusiveProd
  putStrLn "Wrote Elusive icon-hs-file."
  fiProd
  putStrLn "Wrote Foundation icon-hs-file."
  icomoonProd
  putStrLn "Wrote Icomoon icon-hs-file."
  ionProd
  putStrLn "Wrote Ionicons icon-hs-file."
  matDesignProd
  putStrLn "Wrote Material Design icon-hs-file."
  mfgProd
  putStrLn "Wrote MfgLabs icon-hs-file."
  -- modUIProd
  -- putStrLn "Wrote ModernUI icon-hs-file."
  oiProd
  putStrLn "Wrote OpenIconic icon-hs-file."
  typiProd
  putStrLn "Wrote Typicons icon-hs-file."
  flagProd
  putStrLn "Wrote flag-icons icon-hs-file."
  --
  bs4gen
  putStrLn "Wrote bootstrap theme-hs-file."
  semgen
  putStrLn "Wrote semantic theme-hs-file."
  fougen
  putStrLn "Wrote foundation theme-hs-file."
-}

